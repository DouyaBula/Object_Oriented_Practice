# 面向对象第四次实验第一部分指导书

> 本部分实验题目仓库地址：http://gitlab.oo.buaa.edu.cn/2023_public/experiment/exp4_1_public

## 实验目标

 - 掌握多线程的基本知识，如多线程的运行、wait、notifyAll的使用等。
 - 理解死锁等线程安全问题的特征，掌握线程安全设计方法
 - 了解锁的作用和原理，学会读写锁的使用

## 实验要求

​		**代码中需要补全的部分已经用 `TODO` 标出，请根据题意完善代码，并提交到个人实验仓库中以完成本次实验**

​		**本次实验仅允许补充标出 `TODO` 的部分，不允许更改其他部分代码，否则将会被视为无效实验**

## 实验说明

​		在多线程程序设计中，锁是一个非常重要的概念，锁的存在保证了同步区的代码每次至多只有一个线程在执行。而锁本身又可细分为读写锁和非读写锁。

​		我们在之前的作业中较常使用的`synchronized`关键字是非读写锁，此时同步区代码每次严格至多只有一个线程执行。

​		但我们知道，数据冲突只有读-写冲突和写-写冲突两种，**多个线程对同一个数据只进行读操作时是不会产生冲突的**（一般称这些线程为读者线程，既读又写或者只写的线程称为写者）。而非读写锁不论读者或写者，每次都只让一个线程对同步区代码进行访问，这显然降低了多线程程序的效率，因此读写锁的概念应运而生。

​		读写锁相当于在非读写锁的基础上稍微放宽了线程执行同步区代码的条件，即**同步区允许存在多个读者执行，但是同步区至多只能有一个写者，且写者存在时同步区不允许存在读者**。

​		本次实验第一部分要求在一个特定的业务背景下使用读写锁完成任务。

## 实验任务

​		数据库作为一个长期存储在计算机内的、有组织的、可共享的、统一管理的大量数据的集合，在当下的大数据时代发挥着越来越重要的作用。而数据库的四个基本操作（添加，删除，修改，查询）中，查询操作的比例远大于其他三种操作，所以需要使用读写锁来提高数据库系统的效率。本任务中要求同学们模拟实现一个简易的“键值数据库”系统。

题目基本信息如下：

#### 官方包解读

```
src
| - Database.java //数据库类
| - InsertThread.java // 数据库插入线程，负责进行数据库插入操作
| - Main.java // 程序的入口
| - SelectThread.java // 数据库查询线程，负责进行数据库查询操作
```

#### 输入格式

​		输入共$n+m+2$行。

​		第1行为一个整数$n$，表示用于插入数据的线程数目。

​		接下来$n$行，每行有两个不含空格和制表符的字符串$s_1, s_2$，以一个空格隔开，对第$i+1$行输入的字符串$s_{i1}, s_{i2}$。表示第$i$个插入线程会往数据库里执行插入$(s_{i1},s_{i2})$键值对的操作。

​		第$n+2$行为一个整数$m$，表示用于查找数据的线程数目。

​		接下来$m$行，每行有一个不含空格和制表符的字符串$s$，对第$n+2+j$行输入的字符串$s_j$，表示第$j$个查询线程会从数据库里查找$s_j$对应的值并输出。

#### 输出格式

- 插入数据成功：`<ThreadName>:insert(<key>, <value>)`
- 查询到`key`对应数据：`<counter>:<key> => <value>`
- 查询不到`key`对应数据：`<counter>:<key> => null`

#### 程序简要逻辑

​		程序从输入中读取到各线程配置后启动这些线程，这些线程会按照设定好的参数不断进行插入或查询操作。当整个程序运行到设定好的最大时间后将直接退出。

#### 输入样例

```
2
A a
A b
1
A
```

#### 输出样例

```
[   1.3830]Thread-0:insert(A, a)
[   1.8860]Thread-1:insert(A, b)
[   1.9410]1:A => b
[   2.4430]Thread-1:insert(A, b)
[   2.4990]2:A => b
[   3.0040]Thread-0:insert(A, a)
[   3.0580]3:A => a
[   3.5580]Thread-0:insert(A, a)
[   3.6140]4:A => a
[   4.1190]Thread-1:insert(A, b)
[   4.1720]5:A => b
[   4.2270]6:A => b
[   4.2830]7:A => b
[   4.3350]8:A => b
[   4.8400]Thread-0:insert(A, a)
[   4.8920]9:A => a
[   5.3920]Thread-1:insert(A, b)
[   5.4450]10:A => b
```

## 实验提示

​		读写锁，顾名思义，分为读锁和写锁。当线程只涉及读操作（即读者线程）时应当获取读锁，线程涉及到写操作时就需要获取写锁。读锁可同时被多个读者线程获取，即多个读者线程可以同时读取共享对象的内容，当读锁被获取后写锁就不能再被获取，直到读锁被完全释放；写锁只能被一个线程获取，即同一时间至多一个线程可以更改共享对象的内容，当写锁被获取后读锁就不能再被获取，直到写锁被释放。

​		java官方包读写锁使用的一个样例如下。

```java
private final ReadWriteLock rwLock = new ReentrantReadWriteLock();
private final Lock readLock = rwLock.readLock();
private final Lock writeLock = rwLock.writeLock();

public void reader() {
	readLock.lock();
	try {
		//在此区域读取共享变量
	} finally {
		readLock.unlock();  //总是在finally块中释放锁，以免锁泄露
	}
}

public void writer() {
	writeLock.lock();
	try {
		//在此区域读写共享变量
	} finally {
		writeLock.unlock(); //总是在finally块中释放锁，以免锁泄露
	}
}
```

